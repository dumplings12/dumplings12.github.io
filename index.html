<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>11XXXXX -FinalTerm</title>
  <style>
    :root{
      --bg1:#1f2937; --bg2:#111827; --card:#0b1220cc;
      --text:#e5e7eb; --muted:#9ca3af; --accent:#f59e0b;
      --wood:#c89b62;
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh;
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(1200px 600px at 20% 10%, #334155, transparent),
                  radial-gradient(900px 500px at 80% 40%, #1f2937, transparent),
                  linear-gradient(135deg,var(--bg1),var(--bg2));
      color:var(--text);
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans TC","PingFang TC",sans-serif;
      padding:24px;
    }
    .wrap{
      width:min(980px, 100%);
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap:18px;
    }
    @media (max-width: 880px){
      .wrap{ grid-template-columns: 1fr; }
    }
    .card{
      background: var(--card);
      border:1px solid rgba(255,255,255,.08);
      border-radius:18px;
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
      overflow:hidden;
    }
    header{
      padding:16px 18px 10px;
      border-bottom:1px solid rgba(255,255,255,.08);
      display:flex; justify-content:space-between; align-items:center; gap:12px;
    }
    header h1{ margin:0; font-size:18px; letter-spacing:.3px; }
    header .pill{
      padding:6px 10px; border-radius:999px;
      background: rgba(245,158,11,.12);
      border:1px solid rgba(245,158,11,.35);
      color: #ffd28a;
      font-size:12px;
      white-space:nowrap;
    }
    .boardArea{ padding:14px; display:flex; justify-content:center; }
    canvas{
      width: min(560px, 95vw);
      height: auto;
      background: linear-gradient(180deg, #d7b07a, #b6864f);
      border-radius: 14px;
      border: 2px solid rgba(0,0,0,.35);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08),
                  0 14px 25px rgba(0,0,0,.35);
      touch-action: manipulation;
    }
    .side{ padding:16px; display:flex; flex-direction:column; gap:12px; }
    .status{
      padding:12px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(17,24,39,.55);
      line-height:1.5;
      font-size:14px;
    }
    .row{ display:flex; gap:10px; flex-wrap:wrap; }
    button{
      appearance:none; border:none;
      padding:10px 12px;
      border-radius: 12px;
      background: rgba(59,130,246,.16);
      border: 1px solid rgba(59,130,246,.35);
      color: var(--text);
      cursor:pointer;
      font-weight:600;
    }
    button:hover{ filter:brightness(1.1); }
    button:disabled{ opacity:.45; cursor:not-allowed; }
    .warnBtn{
      background: rgba(245,158,11,.14);
      border-color: rgba(245,158,11,.40);
    }
    .dangerBtn{
      background: rgba(239,68,68,.14);
      border-color: rgba(239,68,68,.40);
    }
    .small{
      font-size:12px; color:var(--muted);
      line-height:1.5;
    }
    .kpi{
      display:grid; grid-template-columns: 1fr 1fr; gap:10px;
    }
    .kpi .box{
      padding:10px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.08);
    }
    .kpi .box .t{ font-size:12px; color:var(--muted); }
    .kpi .box .v{ font-size:20px; font-weight:800; margin-top:2px; }
    .kbd{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .hr{ height:1px; background: rgba(255,255,255,.08); margin:2px 0; }
    .list{ margin:0; padding-left:18px; }
    .badge{
      display:inline-block; padding:2px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.15);
      background: rgba(255,255,255,.06);
      font-size:12px; color:var(--muted);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <header>
        <h1>ä¹è·¯åœæ£‹ï¼ˆBlack: User å…ˆæ‰‹ï¼ŒWhite: Computer å¾Œæ‰‹ï¼‰</h1>
        <div class="pill" id="modePill">å°å±€ä¸­</div>
      </header>
      <div class="boardArea">
        <canvas id="goCanvas" width="640" height="640" aria-label="9x9 Go board"></canvas>
      </div>
    </div>

    <div class="card">
      <div class="side">
        <div class="status" id="status"></div>

        <div class="kpi">
          <div class="box">
            <div class="t">é»‘ï¼ˆä½ ï¼‰æå­æ•¸</div>
            <div class="v" id="capB">0</div>
          </div>
          <div class="box">
            <div class="t">ç™½ï¼ˆé›»è…¦ï¼‰æå­æ•¸</div>
            <div class="v" id="capW">0</div>
          </div>
          <div class="box">
            <div class="t">é€£çºŒ Pass</div>
            <div class="v"><span id="passN">0</span><span class="badge">/2</span></div>
          </div>
          <div class="box">
            <div class="t">æœ€å¾Œä¸€æ­¥</div>
            <div class="v kbd" style="font-size:16px" id="lastMove">-</div>
          </div>
        </div>

        <div class="row">
          <button class="warnBtn" id="btnPass">Pass</button>
          <button id="btnUndo">æ‚”æ£‹</button>
          <button class="dangerBtn" id="btnNew">æ–°å±€</button>
        </div>

        <div class="row">
          <button id="btnAI">AIï¼šé–‹</button>
          <button id="btnHelp">è¦å‰‡æç¤º</button>
        </div>

        <div class="hr"></div>

        

      </div>
    </div>
  </div>

<script>
(() => {
  // =========================
  // 0) å°å·¥å…·
  // =========================
  const N = 9;
  const BLACK = 1;
  const WHITE = -1;
  const EMPTY = 0;

  const deepCopyBoard = (b) => b.map(row => row.slice());
  const boardToKey = (b) => b.flat().join(',');

  const inRange = (r,c) => r>=0 && r<N && c>=0 && c<N;

  const dirs4 = [[-1,0],[1,0],[0,-1],[0,1]];

  function neighbors4(r,c){
    const out = [];
    for (const [dr,dc] of dirs4){
      const nr=r+dr, nc=c+dc;
      if (inRange(nr,nc)) out.push([nr,nc]);
    }
    return out;
  }

  function fmtRC(r,c){
    // é¡¯ç¤ºæˆ (1..9, 1..9)
    return `(${r+1},${c+1})`;
  }

  // =========================
  // 1) ç›¤é¢ & æ£‹ä¸²ï¼ˆGroupï¼‰
  // =========================
  function getGroup(board, sr, sc){
    const color = board[sr][sc];
    if (color === EMPTY) return { stones: [], color, liberties: new Set() };

    const visited = Array.from({length:N}, () => Array(N).fill(false));
    const stack = [[sr,sc]];
    const stones = [];
    const liberties = new Set();

    visited[sr][sc]=true;

    while(stack.length){
      const [r,c] = stack.pop();
      stones.push([r,c]);

      for (const [nr,nc] of neighbors4(r,c)){
        if (board[nr][nc] === EMPTY){
          liberties.add(nr + ',' + nc);
        } else if (board[nr][nc] === color && !visited[nr][nc]){
          visited[nr][nc]=true;
          stack.push([nr,nc]);
        }
      }
    }

    return { stones, color, liberties };
  }

  function removeStones(board, stones){
    for (const [r,c] of stones) board[r][c]=EMPTY;
  }

  // =========================
  // 2) åˆæ³•æ€§ï¼šè‡ªæ®º + Koï¼ˆç«‹å³é‚„åŸç¦æ‰‹ï¼‰
  // =========================
  function playOnBoard(board, r, c, color){
    // å›å‚³ï¼š{nextBoard, capturedCount, capturedStones}
    const next = deepCopyBoard(board);
    next[r][c]=color;

    let captured = [];
    const opp = -color;

    // çœ‹å››å‘¨å°æ‰‹æ£‹ä¸²æ˜¯å¦è¢«æ
    for (const [nr,nc] of neighbors4(r,c)){
      if (next[nr][nc] === opp){
        const g = getGroup(next, nr, nc);
        if (g.liberties.size === 0){
          captured = captured.concat(g.stones);
        }
      }
    }
    if (captured.length){
      removeStones(next, captured);
    }

    // æœ€å¾Œæª¢æŸ¥è‡ªå·±æ˜¯å¦è‡ªæ®ºï¼ˆè‹¥æ²’åƒå­ï¼Œè‡ªå·±æ°£å¿…é ˆ>0ï¼‰
    const self = getGroup(next, r, c);
    const suicide = (self.liberties.size === 0);
    return { nextBoard: next, capturedCount: captured.length, capturedStones: captured, suicide };
  }

  // =========================
  // 3) ç°¡æ˜“ AIï¼šèƒ½åƒå°±åƒ / é¿å…é€æ­» / åå¥½ä¸­å¿ƒ
  // =========================
  function scoreMove(board, r, c, color){
    const sim = playOnBoard(board, r, c, color);
    if (sim.suicide) return -1e9;

    let s = 0;
    // åƒå­åŠ åˆ†
    s += sim.capturedCount * 50;

    // ä½ç½®åå¥½ï¼šä¸­å¿ƒ > æ˜Ÿä½ > é‚Šè§’
    const center = 4;
    const dist = Math.abs(r-center) + Math.abs(c-center);
    s += (10 - dist);

    // è‹¥é€ æˆå°æ‰‹å«åƒï¼ˆå°æ‰‹æŸä¸²åªå‰©1æ°£ï¼‰â†’ åŠ åˆ†
    s += countAtari(sim.nextBoard, -color) * 8;

    // é¿å…è®“è‡ªå·±è¢«å«åƒï¼ˆè‡ªå·±æŸä¸²åªå‰©1æ°£ï¼‰â†’ æ‰£åˆ†
    s -= countAtari(sim.nextBoard, color) * 10;

    return s;
  }

  function allLegalMoves(board, color, prevKey){
    const moves = [];
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (board[r][c] !== EMPTY) continue;
        const sim = playOnBoard(board, r, c, color);
        if (sim.suicide) continue;

        // Koï¼šç¦æ­¢ã€Œä¸‹ä¸€æ‰‹å¾Œç›¤é¢ã€ç­‰æ–¼ã€Œä¸Šä¸€æ‰‹å‰ç›¤é¢ã€
        // prevKey = ä¸Šä¸€å€‹å±€é¢ï¼ˆå°æ–¹ä¸‹å®Œå¾Œï¼‰çš„ keyï¼›æˆ‘å€‘è¦é¿å… sim.nextBoard == previousPrevious? é€™è£¡åšæœ€ç°¡ Koï¼šé¿å…å›åˆ°ä¸Šä¸€æ­¥å±€é¢
        // åšæ³•ï¼šå‚³å…¥ koBannedKeyï¼ˆä¸Šä¸€æ‰‹å±€é¢ keyï¼‰ï¼Œå¦‚æœ sim.nextBoard çš„ key ç­‰æ–¼ koBannedKeyï¼Œå°±ç¦
        const key = boardToKey(sim.nextBoard);
        if (key === prevKey) continue;

        moves.push({r,c, sim});
      }
    }
    return moves;
  }

  // =========================
  // 4) å«åƒ (Atari) è¨ˆæ•¸ï¼šæŸè‰²æ£‹ä¸²åªæœ‰ 1 å£æ°£
  // =========================
  function countAtari(board, color){
    const visited = Array.from({length:N}, () => Array(N).fill(false));
    let atariGroups = 0;

    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (board[r][c] !== color || visited[r][c]) continue;
        const g = getGroup(board, r, c);
        for (const [sr,sc] of g.stones) visited[sr][sc]=true;
        if (g.liberties.size === 1) atariGroups++;
      }
    }
    return atariGroups;
  }

  // =========================
  // 5) çµ‚å±€è¨ˆåˆ†ï¼ˆç°¡åŒ–ï¼‰ï¼šé¢ç©åˆ¶ï¼ˆStone + Territoryï¼‰
  //    ä¸¦æä¾›ã€Œæ¨™è¨˜æ­»å­ã€ä¾†åšæ´»æ£‹åˆ¤æ–·ï¼ˆäººå·¥è¼”åŠ©ï¼‰
  // =========================
  function computeAreaScore(board, deadMask){
    // deadMask[r][c] = true è¡¨ç¤ºè©²å­è¢«æ¨™ç‚ºæ­»å­ï¼ˆå…ˆå¾ç›¤é¢ç§»é™¤å†ç®—ï¼‰
    const b = deepCopyBoard(board);
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (deadMask[r][c] && b[r][c] !== EMPTY){
          b[r][c] = EMPTY;
        }
      }
    }

    let black = 0, white = 0;

    // 1) æ£‹å­æœ¬èº«
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (b[r][c] === BLACK) black++;
        else if (b[r][c] === WHITE) white++;
      }
    }

    // 2) ç©ºé»åœåœ°
    const visited = Array.from({length:N}, () => Array(N).fill(false));

    function flood(sr,sc){
      const stack = [[sr,sc]];
      visited[sr][sc]=true;
      let pts = [[sr,sc]];
      let border = new Set();

      while(stack.length){
        const [r,c] = stack.pop();
        for (const [nr,nc] of neighbors4(r,c)){
          if (b[nr][nc] === EMPTY && !visited[nr][nc]){
            visited[nr][nc]=true;
            stack.push([nr,nc]);
            pts.push([nr,nc]);
          } else if (b[nr][nc] !== EMPTY){
            border.add(b[nr][nc]); // +1 or -1
          }
        }
      }
      return { pts, border };
    }

    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (b[r][c] !== EMPTY || visited[r][c]) continue;
        const reg = flood(r,c);

        // åªæœ‰å–®è‰²é‚Šç•Œæ‰ç®—è©²è‰²é ˜åœ°
        if (reg.border.size === 1){
          const only = [...reg.border][0];
          if (only === BLACK) black += reg.pts.length;
          if (only === WHITE) white += reg.pts.length;
        }
      }
    }

    return { black, white };
  }

  // =========================
  // 6) UI / Canvas ç•«æ£‹ç›¤ï¼ˆäº¤å‰é»ï¼‰
  // =========================
  const canvas = document.getElementById('goCanvas');
  const ctx = canvas.getContext('2d');

  const statusEl = document.getElementById('status');
  const modePill = document.getElementById('modePill');
  const capBEl = document.getElementById('capB');
  const capWEl = document.getElementById('capW');
  const passEl = document.getElementById('passN');
  const lastMoveEl = document.getElementById('lastMove');

  const btnPass = document.getElementById('btnPass');
  const btnUndo = document.getElementById('btnUndo');
  const btnNew = document.getElementById('btnNew');
  const btnAI = document.getElementById('btnAI');
  const btnHelp = document.getElementById('btnHelp');

  // å¹¾ä½•ï¼š9x9 äº¤å‰é»ï¼Œå¤–æ¡†ç•™ padding
  const PAD = 70;
  const SIZE = canvas.width;
  const CELL = (SIZE - PAD*2) / (N-1);
  const STONE_R = CELL * 0.42;

  function rcToXY(r,c){
    return { x: PAD + c*CELL, y: PAD + r*CELL };
  }

  function xyToRC(x,y){
    // æ‰¾æœ€è¿‘äº¤å‰é»
    const c = Math.round((x - PAD) / CELL);
    const r = Math.round((y - PAD) / CELL);
    if (!inRange(r,c)) return null;
    const p = rcToXY(r,c);
    const d = Math.hypot(p.x - x, p.y - y);
    if (d > CELL*0.45) return null;
    return { r, c };
  }

  function drawBoard(){
    ctx.clearRect(0,0,SIZE,SIZE);

    // èƒŒæ™¯æœ¨ç´‹ï¼ˆç°¡å–®ï¼‰
    const grd = ctx.createLinearGradient(0,0,0,SIZE);
    grd.addColorStop(0,'#d9b07a');
    grd.addColorStop(1,'#b5844e');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,SIZE,SIZE);

    // å¤–æ¡†
    ctx.strokeStyle = 'rgba(0,0,0,.55)';
    ctx.lineWidth = 4;
    ctx.strokeRect(PAD-22, PAD-22, (N-1)*CELL + 44, (N-1)*CELL + 44);

    // æ ¼ç·š
    ctx.strokeStyle = 'rgba(0,0,0,.75)';
    ctx.lineWidth = 2;

    for (let i=0;i<N;i++){
      // æ©«ç·š
      ctx.beginPath();
      ctx.moveTo(PAD, PAD + i*CELL);
      ctx.lineTo(PAD + (N-1)*CELL, PAD + i*CELL);
      ctx.stroke();

      // ç›´ç·š
      ctx.beginPath();
      ctx.moveTo(PAD + i*CELL, PAD);
      ctx.lineTo(PAD + i*CELL, PAD + (N-1)*CELL);
      ctx.stroke();
    }

    // æ˜Ÿä½ï¼š9è·¯å¸¸ç”¨ (3,3),(3,7),(7,3),(7,7),(5,5) -> 0-based (2,2),(2,6),(6,2),(6,6),(4,4)
    const hoshi = [[2,2],[2,6],[6,2],[6,6],[4,4]];
    ctx.fillStyle = 'rgba(0,0,0,.75)';
    for (const [r,c] of hoshi){
      const {x,y} = rcToXY(r,c);
      ctx.beginPath();
      ctx.arc(x,y,5,0,Math.PI*2);
      ctx.fill();
    }
  }

  function drawStone(r,c,color, isLast=false, isDead=false){
    const {x,y} = rcToXY(r,c);
    // é™°å½±
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,.35)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetY = 4;

    // æ£‹å­
    const g = ctx.createRadialGradient(x-STONE_R*0.3, y-STONE_R*0.3, STONE_R*0.2, x, y, STONE_R);
    if (color === BLACK){
      g.addColorStop(0, '#3b3b3b');
      g.addColorStop(1, '#0b0b0b');
    } else {
      g.addColorStop(0, '#ffffff');
      g.addColorStop(1, '#d8d8d8');
    }
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(x,y,STONE_R,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // æœ€å¾Œä¸€æ‰‹é«˜äº®
    if (isLast){
      ctx.strokeStyle = 'rgba(245,158,11,.95)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(x,y,STONE_R+4,0,Math.PI*2);
      ctx.stroke();
    }

    // æ­»å­æ¨™è¨˜
    if (isDead){
      ctx.strokeStyle = 'rgba(239,68,68,.95)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(x-STONE_R*0.6, y-STONE_R*0.6);
      ctx.lineTo(x+STONE_R*0.6, y+STONE_R*0.6);
      ctx.moveTo(x+STONE_R*0.6, y-STONE_R*0.6);
      ctx.lineTo(x-STONE_R*0.6, y+STONE_R*0.6);
      ctx.stroke();
    }
  }

  // =========================
  // 7) éŠæˆ²ç‹€æ…‹
  // =========================
  let board, current, aiEnabled, gameOver, consecutivePasses;
  let capturesBlack, capturesWhite;
  let history; // stack of snapshots: {board, current, passes, capB, capW, lastMove, koKey}
  let lastMove = null;
  let koBannedKey = null; // ç°¡åŒ– Koï¼šç¦æ­¢å›åˆ°ä¸Šä¸€æ‰‹å±€é¢

  // scoring mode
  let scoringMode = false;
  let dead = Array.from({length:N}, () => Array(N).fill(false));

  function resetGame(){
    board = Array.from({length:N}, () => Array(N).fill(EMPTY));
    current = BLACK; // ä½¿ç”¨è€…é»‘å…ˆ
    aiEnabled = true;
    gameOver = false;
    consecutivePasses = 0;
    capturesBlack = 0;
    capturesWhite = 0;
    history = [];
    lastMove = null;
    koBannedKey = null;
    scoringMode = false;
    dead = Array.from({length:N}, () => Array(N).fill(false));

    pushHistory();
    updateUI();
    render();
  }

  function pushHistory(){
    history.push({
      board: deepCopyBoard(board),
      current,
      consecutivePasses,
      capturesBlack,
      capturesWhite,
      lastMove: lastMove ? {...lastMove} : null,
      koBannedKey
    });
  }

  function popHistory(){
    if (history.length <= 1) return null;
    history.pop();
    const prev = history[history.length-1];
    board = deepCopyBoard(prev.board);
    current = prev.current;
    consecutivePasses = prev.consecutivePasses;
    capturesBlack = prev.capturesBlack;
    capturesWhite = prev.capturesWhite;
    lastMove = prev.lastMove ? {...prev.lastMove} : null;
    koBannedKey = prev.koBannedKey;
    gameOver = false;
    scoringMode = false;
    dead = Array.from({length:N}, () => Array(N).fill(false));
    updateUI();
    render();
    return prev;
  }

  function render(){
    drawBoard();

    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (board[r][c] === EMPTY) continue;
        const isLast = lastMove && lastMove.r===r && lastMove.c===c;
        const isDead = scoringMode ? dead[r][c] : false;
        drawStone(r,c,board[r][c], isLast, isDead);
      }
    }
  }

  function hasAnyLegalMove(color){
    const moves = allLegalMoves(board, color, koBannedKey);
    return moves.length > 0;
  }

  function setStatus(html){
    statusEl.innerHTML = html;
  }

  function updateUI(){
    capBEl.textContent = capturesBlack;
    capWEl.textContent = capturesWhite;
    passEl.textContent = consecutivePasses;

    btnUndo.disabled = (history.length <= 1) || scoringMode;
    btnPass.disabled = gameOver && !scoringMode;

    btnAI.textContent = aiEnabled ? 'AIï¼šé–‹' : 'AIï¼šé—œ';

    if (!lastMove) lastMoveEl.textContent = '-';
    else lastMoveEl.textContent = `${lastMove.color===BLACK?'B':'W'} ${fmtRC(lastMove.r,lastMove.c)}`;

    if (scoringMode){
      modePill.textContent = 'çµ‚å±€è¨ˆåˆ†';
      modePill.style.background = 'rgba(239,68,68,.14)';
      modePill.style.borderColor = 'rgba(239,68,68,.40)';
    } else if (gameOver){
      modePill.textContent = 'å·²çµæŸ';
      modePill.style.background = 'rgba(239,68,68,.14)';
      modePill.style.borderColor = 'rgba(239,68,68,.40)';
    } else {
      modePill.textContent = 'å°å±€ä¸­';
      modePill.style.background = 'rgba(245,158,11,.12)';
      modePill.style.borderColor = 'rgba(245,158,11,.35)';
    }

    if (!gameOver && !scoringMode){
      const who = (current===BLACK) ? 'ğŸ–¤ è¼ªåˆ°ä½ ï¼ˆé»‘ï¼‰' : 'âšª é›»è…¦å›åˆï¼ˆç™½ï¼‰';
      const legal = hasAnyLegalMove(current);

      // è‹¥ç•¶å‰ç„¡åˆæ³•è‘—æ‰‹ï¼Œä¾é¡Œæ„å¯åˆ¤å®šç¦è‘—é»å°è‡´è‡ªå‹• passï¼Œä¸¦å¯èƒ½çµ‚å±€
      if (!legal){
        setStatus(`${who}<br><span class="badge">ç„¡åˆæ³•è‘—æ‰‹ â†’ è‡ªå‹• Pass</span>`);
        setTimeout(() => doPass(true), 450);
      } else {
        setStatus(`${who}<br><span class="badge">é»æ£‹ç›¤äº¤å‰é»è½å­</span>`);
      }
    }

    if (scoringMode){
      const s = computeAreaScore(board, dead);
      const w = (s.black > s.white) ? 'ğŸ–¤ é»‘å‹' : (s.white > s.black) ? 'âšª ç™½å‹' : 'å¹³æ‰‹';
      setStatus(`
        <div style="font-weight:800; font-size:16px">çµ‚å±€è¨ˆåˆ†ï¼ˆç°¡åŒ–ï¼‰</div>
        <div class="small" style="margin-top:6px">
          1) å…ˆç”¨æ»‘é¼ é»æ£‹å­ã€Œæ£‹ä¸²ã€æ¨™æˆ<span style="color:#ef4444;font-weight:800">æ­»å­</span>ï¼ˆæœƒæ‰“å‰ï¼‰<br>
          2) å³ä¸‹è§’æ¯”åˆ†æœƒå³æ™‚æ›´æ–°<br>
          3) è‹¥ä½ è¦ºå¾—ä¸ç”¨æ¨™ï¼Œç›´æ¥çœ‹çµæœå³å¯
        </div>
        <div style="margin-top:10px">
          <span class="badge">é»‘ï¼š${s.black}</span>
          <span class="badge">ç™½ï¼š${s.white}</span>
          <span class="badge" style="margin-left:6px">${w}</span>
        </div>
        <div class="small" style="margin-top:8px;color:#fbbf24">
          â€» é€™è£¡çš„ã€Œæ´»æ£‹åˆ¤æ–·ã€æ¡ç”¨ï¼šç”±ä½ æ‰‹å‹•æ¨™æ­»å­ï¼Œé¿å…ç¨‹å¼èª¤åˆ¤ã€‚
        </div>
      `);
    }
  }

  // =========================
  // 8) ä¸‹æ£‹ / Pass / çµ‚å±€
  // =========================
  function doMove(r,c){
    if (gameOver) return;

    if (board[r][c] !== EMPTY) return;

    const sim = playOnBoard(board, r, c, current);
    if (sim.suicide){
      flashMsg('âŒ è‡ªæ®ºç¦æ‰‹ï¼šæ­¤è™•ä¸‹å­æœƒæ²’æœ‰æ°£ï¼Œä¸”æ²’æœ‰æåˆ°å°æ‰‹å­ã€‚');
      return;
    }

    // Koï¼šç¦æ­¢å›åˆ°ä¸Šä¸€æ‰‹å±€é¢ï¼ˆç°¡åŒ–ï¼‰
    const nextKey = boardToKey(sim.nextBoard);
    if (nextKey === koBannedKey){
      flashMsg('âŒ æ‰“åŠ«ï¼ˆKoï¼‰ç¦æ‰‹ï¼šä¸å¯ç«‹å³å›åˆ°ä¸Šä¸€æ‰‹å±€é¢ã€‚');
      return;
    }

    // âœ… æˆåŠŸè½å­
    const prevPosKey = boardToKey(board); // ç”¨ä¾†çµ¦ä¸‹ä¸€æ‰‹åš koBannedKey
    board = sim.nextBoard;

    // è¨˜éŒ„æå­
    if (sim.capturedCount){
      if (current === BLACK) capturesBlack += sim.capturedCount;
      else capturesWhite += sim.capturedCount;
    }

    // å«åƒæç¤ºï¼ˆçœ‹å°æ‰‹æ˜¯å¦æœ‰æŸä¸²åªå‰© 1 æ°£ï¼‰
    const atariOpp = countAtari(board, -current);

    lastMove = { r, c, color: current };
    consecutivePasses = 0;

    // æ›´æ–° Ko ç¦æ‰‹ key
    koBannedKey = prevPosKey;

    // æ›æ‰‹
    current = -current;

    pushHistory();
    render();
    updateUI();

    if (atariOpp > 0){
      flashMsg(`âš ï¸ å«åƒæç¤ºï¼šå°æ‰‹æœ‰ ${atariOpp} ä¸²åªå‰© 1 å£æ°£ã€‚`);
    }

    // AI è¡Œå‹•
    if (!gameOver && aiEnabled && current === WHITE){
      setTimeout(aiTurn, 450);
    }
  }

  function doPass(auto=false){
    if (gameOver) return;

    consecutivePasses++;

    // è‹¥é›™æ–¹é€£çºŒ pass å…©æ¬¡ â†’ é€²å…¥è¨ˆåˆ†
    if (consecutivePasses >= 2){
      enterScoringMode('âœ… é›™æ–¹é€£çºŒ Pass å…©æ¬¡ â†’ çµ‚å±€è¨ˆåˆ†');
      return;
    }

    // è‹¥é›™æ–¹éƒ½æ²’æœ‰åˆæ³•è‘—æ‰‹ â†’ ç›´æ¥çµ‚å±€è¨ˆåˆ†
    const meHas = hasAnyLegalMove(current);
    const oppHas = hasAnyLegalMove(-current);
    if (!meHas && !oppHas){
      enterScoringMode('âœ… é›™æ–¹çš†ç„¡åˆæ³•è‘—æ‰‹ï¼ˆå…¨ç¦è‘—é»ï¼‰â†’ çµ‚å±€è¨ˆåˆ†');
      return;
    }

    // æ›æ‰‹
    current = -current;

    pushHistory();
    render();
    updateUI();

    if (!auto){
      flashMsg('â­ï¸ Passã€‚');
    }

    if (aiEnabled && current === WHITE){
      setTimeout(aiTurn, 450);
    }
  }

  function enterScoringMode(reason){
    gameOver = true;
    scoringMode = true;
    flashMsg(reason);

    // è¨ˆåˆ†æ¨¡å¼ï¼šå…è¨±é»æ“Šæ£‹ä¸²æ¨™æ­»å­
    updateUI();
    render();
  }

  function aiTurn(){
    if (gameOver || scoringMode) return;
    if (current !== WHITE) return;

    const moves = allLegalMoves(board, WHITE, koBannedKey);
    if (moves.length === 0){
      doPass(true);
      return;
    }

    // é¸æœ€é«˜åˆ†
    let best = null;
    let bestS = -1e18;
    for (const m of moves){
      const s = scoreMove(board, m.r, m.c, WHITE);
      if (s > bestS){
        bestS = s;
        best = m;
      }
    }

    if (!best){
      doPass(true);
      return;
    }

    doMove(best.r, best.c);
  }

  function flashMsg(msg){
    // çŸ­æš«è¨Šæ¯ï¼šç–Šåœ¨ status ä¸‹æ–¹
    const old = statusEl.innerHTML;
    statusEl.innerHTML = old + `<div style="margin-top:8px;color:#fbbf24;font-weight:700">${msg}</div>`;
    setTimeout(() => updateUI(), 1100);
  }

  // =========================
  // 9) è¨ˆåˆ†æ¨¡å¼ï¼šé»æ£‹ä¸²åˆ‡æ›æ­»æ´»
  // =========================
  function toggleDeadGroup(r,c){
    if (!scoringMode) return;
    if (board[r][c] === EMPTY) return;

    const g = getGroup(board, r, c);
    // è‹¥é€™ä¸²è£¡ä»»ä¸€å­å·²è¢«æ¨™æ­»ï¼Œè¦–ç‚ºæ•´ä¸² currentlyDead=true
    let currentlyDead = false;
    for (const [sr,sc] of g.stones){
      if (dead[sr][sc]) { currentlyDead = true; break; }
    }
    const newVal = !currentlyDead;
    for (const [sr,sc] of g.stones){
      dead[sr][sc] = newVal;
    }
    render();
    updateUI();
  }

  // =========================
  // 10) äº‹ä»¶
  // =========================
  canvas.addEventListener('click', (ev) => {
    const rect = canvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left) * (canvas.width / rect.width);
    const y = (ev.clientY - rect.top) * (canvas.height / rect.height);

    const rc = xyToRC(x,y);
    if (!rc) return;

    if (scoringMode){
      toggleDeadGroup(rc.r, rc.c);
      return;
    }

    // å°å±€ä¸­ï¼šåªæœ‰é»‘æ£‹ï¼ˆä½¿ç”¨è€…ï¼‰å¯é»
    if (current !== BLACK) return;
    doMove(rc.r, rc.c);
  });

  btnPass.addEventListener('click', () => doPass(false));
  btnUndo.addEventListener('click', () => popHistory());
  btnNew.addEventListener('click', () => resetGame());
  btnAI.addEventListener('click', () => { aiEnabled = !aiEnabled; updateUI(); if (aiEnabled && current===WHITE && !gameOver) setTimeout(aiTurn, 350); });
  btnHelp.addEventListener('click', () => {
    alert(
`ä¹è·¯åœæ£‹ï¼ˆç°¡åŒ–ç‰ˆï¼‰è¦å‰‡æç¤º
1) é»‘å…ˆç™½å¾Œï¼ˆç™½ç”±é›»è…¦ä¸‹ï¼‰
2) è½å­åœ¨äº¤å‰é»ï¼ˆæ ¼ç·šäº¤å‰è™•ï¼‰
3) æå­ï¼šå°æ‰‹æ£‹ä¸²ç„¡æ°£æœƒè¢«æ‹¿æ‰
4) ç¦è‘—é»ï¼š
   - è‡ªæ®ºç¦æ‰‹ï¼ˆä¸‹å®Œè‡ªå·±é‚£ä¸²æ²’æ°£ä¸”æ²’æœ‰æå­ï¼‰
   - ç°¡åŒ– Koï¼šç¦æ­¢ã€Œç«‹å³ã€å›åˆ°ä¸Šä¸€æ‰‹å±€é¢
5) çµ‚å±€ï¼š
   - é›™æ–¹é€£çºŒ Pass å…©æ¬¡
   - æˆ–é›™æ–¹éƒ½ç„¡åˆæ³•è‘—æ‰‹ï¼ˆå…¨ç¦è‘—é»ï¼‰
6) çµ‚å±€æ±ºç®—ï¼ˆç°¡åŒ–ï¼‰ï¼š
   - ä½ å¯ä»¥é»æ£‹ä¸²æ¨™ã€Œæ­»å­ã€ï¼ˆæ‰“ç´…å‰ï¼‰
   - æœƒæŠŠæ­»å­ç§»é™¤å¾Œï¼Œç”¨é¢ç©åˆ¶ï¼ˆå­æ•¸+åœåœ°ï¼‰ç®—åˆ†`
    );
  });

  // =========================
  // 11) å•Ÿå‹•
  // =========================
  resetGame();

})();
</script>
</body>
</html>
