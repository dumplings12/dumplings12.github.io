<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>11XXXXX - FinalTerm</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: #ecf0f1;
        }
        .game-container {
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
        }
        h1 {
            font-size: 2.5em;
            background: linear-gradient(45deg, #f39c12, #e67e22);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .status {
            font-size: 1.2em;
            margin: 20px 0;
            padding: 15px;
            background: rgba(52, 73, 94, 0.8);
            border-radius: 10px;
            border: 2px solid #3498db;
            line-height: 1.5;
            min-height: 60px;
        }
        #board {
            display: grid;
            grid-template-columns: repeat(9, 50px);
            grid-template-rows: repeat(9, 50px);
            gap: 4px;
            margin: 30px auto;
            padding: 20px;
            background: #1a1a1a;
            border-radius: 15px;
        }
        .cell {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle at center, #8B4513 0%, #654321 70%);
            border: 3px solid #D2691E;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .cell:hover:not(.game-over .cell) { 
            transform: scale(1.05); 
            box-shadow: 0 5px 15px rgba(255,215,0,0.4); 
        }
        .cell.empty::before { 
            content: '+'; 
            color: rgba(255,255,255,0.3); 
            font-size: 24px; 
            font-weight: bold; 
        }
        .black {
            background: radial-gradient(circle at 30% 30%, #000 0%, #333 70%);
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.8), 0 0 20px rgba(0,0,0,0.6);
        }
        .black::after { content: 'â—'; font-size: 32px; color: #fff; text-shadow: 0 1px 2px #000; }
        .white {
            background: radial-gradient(circle at 30% 30%, #fff 0%, #ddd 70%);
            box-shadow: inset 0 2px 8px rgba(255,255,255,0.3), 0 0 20px rgba(255,255,255,0.4);
        }
        .white::after { content: 'â—'; font-size: 32px; color: #333; text-shadow: 0 1px 2px #fff; }
        .captured { animation: capture 0.5s ease-out; }
        @keyframes capture {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.5; }
            100% { transform: scale(0); opacity: 0; }
        }
        button {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white; border: none; padding: 12px 24px;
            margin: 0 5px; border-radius: 25px; font-size: 16px;
            cursor: pointer; transition: all 0.3s;
        }
        button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(52,152,219,0.6); }
        button:disabled { background: #95a5a6; cursor: not-allowed; }
        .pass-btn { background: linear-gradient(45deg, #f39c12, #e67e22) !important; font-weight: bold; }
        .score { display: flex; justify-content: space-around; margin-top: 20px; font-size: 1.3em; font-weight: bold; }
        .black-score { background: rgba(0,0,0,0.7); border: 2px solid #333; padding: 10px; border-radius: 10px; }
        .white-score { background: rgba(255,255,255,0.2); border: 2px solid #ddd; padding: 10px; border-radius: 10px; }
        .game-over { background: rgba(231,76,60,0.9) !important; border-color: #c0392b !important; }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ğŸ¯ ä¹è·¯åœæ£‹</h1>
        <div class="status" id="status">ğŸ–¤ é»‘æ£‹ï¼ˆç©å®¶ï¼‰å…ˆæ‰‹</div>
        <div id="board"></div>
        <div class="controls">
            <button onclick="newGame()">æ–°å±€</button>
            <button class="pass-btn" onclick="game.pass()" id="passBtn">è™›æ‰‹ (Pass)</button>
        </div>
        <div class="score">
            <div class="black-score">é»‘æ£‹: <span id="blackScore">0</span></div>
            <div class="white-score">ç™½æ£‹: <span id="whiteScore">0</span></div>
        </div>
    </div>

    <script>
        class NineBoardGo {
            constructor() {
                this.board = Array(9).fill().map(() => Array(9).fill(0)); // 0:ç©º, 1:é»‘, -1:ç™½
                this.currentPlayer = 1; 
                this.consecutivePasses = 0;
                this.gameOver = false;
                this.initBoard();
                this.updateScores();
            }

            initBoard() {
                const boardEl = document.getElementById('board');
                boardEl.innerHTML = '';
                for (let i = 0; i < 81; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell empty';
                    cell.dataset.row = Math.floor(i / 9);
                    cell.dataset.col = i % 9;
                    cell.addEventListener('click', (e) => this.handleClick(e));
                    boardEl.appendChild(cell);
                }
            }

            handleClick(e) {
                if (this.currentPlayer !== 1 || this.gameOver) return;
                const r = parseInt(e.currentTarget.dataset.row);
                const c = parseInt(e.currentTarget.dataset.col);
                
                if (this.isValidMove(r, c, 1)) {
                    this.makeMove(r, c, 1);
                    this.consecutivePasses = 0;
                    this.currentPlayer = -1;
                    this.updateStatus("âšª é›»è…¦æ€è€ƒä¸­...");
                    setTimeout(() => this.aiMove(), 600);
                } else {
                    alert("ä¸åˆæ³•çš„è½å­ä½ç½®ï¼ˆç¦è‘—é»æˆ–å·²æœ‰æ£‹å­ï¼‰");
                }
            }

            // è®“å­(è™›æ‰‹)è¦å‰‡
            pass() {
                if (this.gameOver) return;
                this.consecutivePasses++;
                
                if (this.consecutivePasses >= 2) {
                    this.endGame("é›™æ–¹è™›æ‰‹ï¼Œçµ‚å±€ï¼");
                    return;
                }
                
                this.currentPlayer = -this.currentPlayer;
                if (this.currentPlayer === -1) {
                    this.updateStatus("âšª ç©å®¶è™›æ‰‹ï¼Œè¼ªåˆ°é›»è…¦...");
                    setTimeout(() => this.aiMove(), 600);
                } else {
                    this.updateStatus("ğŸ–¤ é›»è…¦è™›æ‰‹ï¼Œè¼ªåˆ°ç©å®¶...");
                }
            }

            // ç¦è‘—é»èˆ‡åƒå­é‚è¼¯åˆ¤å®š
            isValidMove(row, col, player) {
                if (this.board[row][col] !== 0) return false;
                
                // æ¨¡æ“¬è½å­
                const tempBoard = this.board.map(r => [...r]);
                tempBoard[row][col] = player;
                const opponent = -player;
                
                // 1. æª¢æŸ¥æ˜¯å¦èƒ½åƒæ‰å°æ–¹
                let canCapture = false;
                const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
                for (let [dr, dc] of dirs) {
                    const nr = row + dr, nc = col + dc;
                    if (this.isInside(nr, nc) && tempBoard[nr][nc] === opponent) {
                        if (!this.hasLiberties(tempBoard, nr, nc, opponent)) {
                            canCapture = true;
                            break;
                        }
                    }
                }
                if (canCapture) return true;
                
                // 2. æª¢æŸ¥è‡ªèº«æ˜¯å¦æœ‰æ°£ (è‹¥ç„¡æ°£ä¸”ä¸èƒ½åƒå­ï¼Œå‰‡ç‚ºç¦è‘—é»)
                return this.hasLiberties(tempBoard, row, col, player);
            }

            makeMove(row, col, player) {
                this.board[row][col] = player;
                const opponent = -player;
                const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
                
                // åŸ·è¡Œåƒå­
                for (let [dr, dc] of dirs) {
                    const nr = row + dr, nc = col + dc;
                    if (this.isInside(nr, nc) && this.board[nr][nc] === opponent) {
                        if (!this.hasLiberties(this.board, nr, nc, opponent)) {
                            this.removeGroup(nr, nc, opponent);
                        }
                    }
                }
                this.updateBoardDisplay();
                this.updateScores();
            }

            aiMove() {
                if (this.gameOver) return;
                let moves = [];
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (this.isValidMove(r, c, -1)) moves.push([r, c]);
                    }
                }
                
                if (moves.length > 0) {
                    // ç°¡æ˜“AIï¼šå„ªå…ˆé¸æ°£å¤šçš„åœ°æ–¹æˆ–éš¨æ©Ÿ
                    const pick = moves[Math.floor(Math.random() * moves.length)];
                    this.makeMove(pick[0], pick[1], -1);
                    this.consecutivePasses = 0;
                    this.currentPlayer = 1;
                    this.updateStatus("ğŸ–¤ ç©å®¶å›åˆ");
                } else {
                    this.pass();
                }
            }

            // æ´ªæ°´å¡«å……è¨ˆç®—æ°£
            hasLiberties(board, r, c, player) {
                const visited = new Set();
                const stack = [[r, c]];
                while (stack.length > 0) {
                    const [currR, currC] = stack.pop();
                    const key = `${currR},${currC}`;
                    if (visited.has(key)) continue;
                    visited.add(key);

                    const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
                    for (let [dr, dc] of dirs) {
                        const nr = currR + dr, nc = currC + dc;
                        if (this.isInside(nr, nc)) {
                            if (board[nr][nc] === 0) return true;
                            if (board[nr][nc] === player) stack.push([nr, nc]);
                        }
                    }
                }
                return false;
            }

            removeGroup(r, c, player) {
                const stack = [[r, c]];
                const visited = new Set();
                while (stack.length > 0) {
                    const [currR, currC] = stack.pop();
                    const key = `${currR},${currC}`;
                    if (visited.has(key)) continue;
                    visited.add(key);

                    if (this.board[currR][currC] === player) {
                        this.board[currR][currC] = 0;
                        const cell = document.querySelector(`[data-row="${currR}"][data-col="${currC}"]`);
                        cell.classList.add('captured');
                        this.getNeighbors(currR, currC).forEach(n => stack.push(n));
                    }
                }
                setTimeout(() => this.updateBoardDisplay(), 500);
            }

            // çµ‚å±€çµç®—èˆ‡æ±ºç®—
            endGame(reason) {
                this.gameOver = true;
                let blackTotal = 0, whiteTotal = 0;
                const visited = new Set();

                // å­ç©ºçš†åœ°è¨ˆç®—
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (this.board[r][c] === 1) blackTotal++;
                        else if (this.board[r][c] === -1) whiteTotal++;
                        else if (!visited.has(`${r},${c}`)) {
                            const territory = this.calculateTerritory(r, c, visited);
                            if (territory.owner === 1) blackTotal += territory.size;
                            else if (territory.owner === -1) whiteTotal += territory.size;
                        }
                    }
                }

                const winner = blackTotal > whiteTotal ? 'ğŸ–¤ é»‘æ£‹å‹' : 'âšª ç™½æ£‹å‹';
                const statusEl = document.getElementById('status');
                statusEl.innerHTML = `${reason}<br>${winner}ï¼<br>æ¯”åˆ†ï¼šé»‘ ${blackTotal} : ç™½ ${whiteTotal}`;
                statusEl.className = 'status game-over';
            }

            calculateTerritory(r, c, globalVisited) {
                let size = 0;
                let reached = new Set();
                let stack = [[r, c]];
                let localVisited = new Set();

                while(stack.length > 0) {
                    const [currR, currC] = stack.pop();
                    const key = `${currR},${currC}`;
                    if (localVisited.has(key)) continue;
                    localVisited.add(key);
                    globalVisited.add(key);
                    size++;

                    const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
                    for (let [dr, dc] of dirs) {
                        const nr = currR + dr, nc = currC + dc;
                        if (this.isInside(nr, nc)) {
                            if (this.board[nr][nc] === 0) stack.push([nr, nc]);
                            else reached.add(this.board[nr][nc]);
                        }
                    }
                }
                // åˆ¤å®šé ˜åœ°æ­¸å±¬ï¼šè‹¥ç©ºåœ°é‚Šç•Œåƒ…æ¥è§¸å–®ä¸€é¡è‰²
                let owner = 0;
                if (reached.size === 1) owner = Array.from(reached)[0];
                return { size, owner };
            }

            updateBoardDisplay() {
                document.querySelectorAll('.cell').forEach(cell => {
                    const r = parseInt(cell.dataset.row), c = parseInt(cell.dataset.col);
                    const val = this.board[r][c];
                    cell.className = 'cell ' + (val === 1 ? 'black' : val === -1 ? 'white' : 'empty');
                });
            }

            updateScores() {
                let b = 0, w = 0;
                this.board.flat().forEach(v => { if(v===1) b++; if(v===-1) w++; });
                document.getElementById('blackScore').textContent = b;
                document.getElementById('whiteScore').textContent = w;
            }

            updateStatus(msg) {
                document.getElementById('status').innerText = msg;
            }

            isInside(r, c) { return r >= 0 && r < 9 && c >= 0 && c < 9; }
            getNeighbors(r, c) {
                return [[r-1, c], [r+1, c], [r, c-1], [r, c+1]].filter(n => this.isInside(n[0], n[1]));
            }
        }

        let game;
        function newGame() { game = new NineBoardGo(); }
        window.onload = () => newGame();
    </script>
</body>
</html>
