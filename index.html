<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>11XXXXX - FinalTerm</title>
    <style>
        :root {
            --board-color: #DEB887;
            --line-color: #333;
        }
        body {
            font-family: "Microsoft JhengHei", sans-serif;
            background-color: #2c3e50;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            margin: 0;
            padding: 20px;
        }
        .container {
            background: #34495e;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center;
        }
        /* 棋盤容器：決定格線背景 */
        .board {
            position: relative;
            width: 450px;
            height: 450px;
            background-color: var(--board-color);
            border: 2px solid #5d4037;
            margin: 20px auto;
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
        }
        /* 繪製格線 */
        .grid-cell {
            position: relative;
            border: 0.5px solid var(--line-color);
            box-sizing: border-box;
        }
        /* 交叉點：透明層用於接收點擊 */
        .intersection-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            z-index: 10;
        }
        .point {
            position: relative;
            width: 50px; height: 50px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* 棋子樣式 */
        .stone {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            z-index: 20;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
        }
        .black { background: radial-gradient(circle at 30% 30%, #444, #000); }
        .white { background: radial-gradient(circle at 30% 30%, #fff, #ccc); }
        
        /* 星位點 */
        .hoshi {
            position: absolute;
            width: 8px; height: 8px;
            background: var(--line-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            left: 50%; top: 50%;
            pointer-events: none;
        }

        .info { margin: 15px 0; font-size: 1.2rem; }
        .controls { margin-top: 15px; }
        button {
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            background: #e67e22;
            border: none;
            color: white;
            border-radius: 5px;
            transition: 0.3s;
        }
        button:hover { background: #d35400; }
        #status { color: #f1c40f; font-weight: bold; height: 1.5em; }
    </style>
</head>
<body>

    <div class="container">
        <h1>九路圍棋電腦對戰</h1>
        <div id="status">黑棋（玩家）先手</div>
        
        <div class="board" id="go-board">
            <script>
                const board = document.getElementById('go-board');
                for(let i=0; i<81; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    // 標註星位 (天元與四角)
                    if([20, 24, 40, 56, 60].includes(i)) {
                        const hoshi = document.createElement('div');
                        hoshi.className = 'hoshi';
                        cell.appendChild(hoshi);
                    }
                    board.appendChild(cell);
                }
            </script>
            
            <div class="intersection-layer" id="intersections"></div>
        </div>

        <div class="info">
            黑棋: <span id="black-score">0</span> | 白棋: <span id="white-score">0</span>
        </div>

        <div class="controls">
            <button onclick="game.pass()">虛手 (Pass)</button>
            <button onclick="location.reload()">重開一局</button>
        </div>
    </div>

<script>
class GoGame {
    constructor() {
        this.size = 9;
        this.board = Array(9).fill().map(() => Array(9).fill(0)); // 0:空, 1:黑, 2:白
        this.currentPlayer = 1;
        this.passCount = 0;
        this.gameOver = false;
        this.initDOM();
    }

    initDOM() {
        const layer = document.getElementById('intersections');
        for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
                const pt = document.createElement('div');
                pt.className = 'point';
                pt.dataset.row = r;
                pt.dataset.col = c;
                pt.onclick = () => this.handleMove(r, c);
                layer.appendChild(pt);
            }
        }
    }

    handleMove(r, c) {
        if (this.gameOver || this.currentPlayer !== 1) return;
        if (this.play(r, c, 1)) {
            this.passCount = 0;
            this.updateUI();
            if (!this.gameOver) {
                document.getElementById('status').innerText = "電腦思考中...";
                setTimeout(() => this.aiMove(), 600);
            }
        }
    }

    // 核心規則：落子
    play(r, c, player) {
        if (this.board[r][c] !== 0) return false;

        // 模擬落子
        const originalBoard = this.board.map(row => [...row]);
        this.board[r][c] = player;
        
        const opponent = player === 1 ? 2 : 1;
        let captured = false;

        // 1. 檢查周圍是否吃掉對方
        this.getNeighbors(r, c).forEach(([nr, nc]) => {
            if (this.board[nr][nc] === opponent) {
                if (this.getLiberties(nr, nc).length === 0) {
                    this.removeGroup(nr, nc);
                    captured = true;
                }
            }
        });

        // 2. 禁著點判定：如果沒吃掉人且自己沒氣，則非法
        if (!captured && this.getLiberties(r, c).length === 0) {
            this.board = originalBoard; // 回溯
            if (player === 1) alert("此處為禁著點！");
            return false;
        }

        this.currentPlayer = opponent;
        return true;
    }

    // 虛手規則
    pass() {
        if (this.gameOver) return;
        this.passCount++;
        this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
        
        if (this.passCount >= 2) {
            this.endGame();
        } else {
            document.getElementById('status').innerText = "一方虛手，換手";
            if (this.currentPlayer === 2) setTimeout(() => this.aiMove(), 600);
        }
        this.updateUI();
    }

    // 簡易AI：優先找有氣的地方落子
    aiMove() {
        if (this.gameOver) return;
        let moves = [];
        for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
                if (this.board[r][c] === 0) moves.push([r, c]);
            }
        }
        
        // 隨機洗牌找合法步
        moves.sort(() => Math.random() - 0.5);
        let moved = false;
        for (let [r, c] of moves) {
            if (this.play(r, c, 2)) {
                moved = true;
                break;
            }
        }

        if (!moved) this.pass();
        this.passCount = 0;
        this.updateUI();
        document.getElementById('status').innerText = "玩家回合 (黑)";
    }

    // 氣的計算 (DFS)
    getLiberties(r, c) {
        const color = this.board[r][c];
        const liberties = new Set();
        const visited = new Set();
        const stack = [[r, c]];

        while (stack.length > 0) {
            const [currR, currC] = stack.pop();
            const key = `${currR},${currC}`;
            if (visited.has(key)) continue;
            visited.add(key);

            this.getNeighbors(currR, currC).forEach(([nr, nc]) => {
                if (this.board[nr][nc] === 0) {
                    liberties.add(`${nr},${nc}`);
                } else if (this.board[nr][nc] === color) {
                    stack.push([nr, nc]);
                }
            });
        }
        return Array.from(liberties);
    }

    removeGroup(r, c) {
        const color = this.board[r][c];
        const stack = [[r, c]];
        while (stack.length > 0) {
            const [currR, currC] = stack.pop();
            if (this.board[currR][currC] === color) {
                this.board[currR][currC] = 0;
                this.getNeighbors(currR, currC).forEach(n => stack.push(n));
            }
        }
    }

    getNeighbors(r, c) {
        return [[r-1, c], [r+1, c], [r, c-1], [r, c+1]].filter(([nr, nc]) => 
            nr >= 0 && nr < 9 && nc >= 0 && nc < 9
        );
    }

    // 終局結算
    endGame() {
        this.gameOver = true;
        let black = 0, white = 0;
        
        // 子空皆地計算 (中國規則簡化版)
        const visited = new Set();
        for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
                if (this.board[r][c] === 1) black++;
                else if (this.board[r][c] === 2) white++;
                else if (!visited.has(`${r},${c}`)) {
                    const territory = this.floodFillTerritory(r, c, visited);
                    if (territory.owner === 1) black += territory.size;
                    if (territory.owner === 2) white += territory.size;
                }
            }
        }

        const result = black > white ? `黑勝 ${black-white} 子` : `白勝 ${white-black} 子`;
        document.getElementById('status').innerText = `終局結算：${result}`;
        alert(`遊戲結束！\n黑棋: ${black}\n白棋: ${white}\n結果: ${result}`);
    }

    floodFillTerritory(r, c, globalVisited) {
        let size = 0;
        let reached = new Set();
        let stack = [[r, c]];
        let localVisited = new Set();

        while(stack.length > 0) {
            const [currR, currC] = stack.pop();
            const key = `${currR},${currC}`;
            if (localVisited.has(key)) continue;
            localVisited.add(key);
            globalVisited.add(key);
            size++;

            this.getNeighbors(currR, currC).forEach(([nr, nc]) => {
                if (this.board[nr][nc] === 0) stack.push([nr, nc]);
                else reached.add(this.board[nr][nc]);
            });
        }
        
        // 如果空地只碰到一種顏色的棋子，則屬於該顏色
        let owner = 0;
        if (reached.size === 1) owner = Array.from(reached)[0];
        return { size, owner };
    }

    updateUI() {
        const points = document.querySelectorAll('.point');
        points.forEach(pt => {
            const r = pt.dataset.row;
            const c = pt.dataset.col;
            pt.innerHTML = '';
            if (this.board[r][c] !== 0) {
                const stone = document.createElement('div');
                stone.className = `stone ${this.board[r][c] === 1 ? 'black' : 'white'}`;
                pt.appendChild(stone);
            }
        });
        
        // 更新即時子數
        let b = 0, w = 0;
        this.board.flat().forEach(v => { if(v===1) b++; if(v===2) w++; });
        document.getElementById('black-score').innerText = b;
        document.getElementById('white-score').innerText = w;
    }
}

const game = new GoGame();
</script>
</body>
</html>
